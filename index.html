<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Converter Circles</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* gray-50 */
            overflow: hidden; /* Prevent scrollbars from appearing */
            touch-action: none;
        }
        .dark body {
            background-color: #0f172a; /* slate-900 */
        }
        .draggable-circle {
            position: absolute;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: grab;
            user-select: none;
            /* transform is now set by JS, so transition is removed */
            line-height: 1.1;
        }
        .draggable-circle.dragging {
            cursor: grabbing;
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
            z-index: 10;
        }
        .bitrate-input {
            background: transparent;
            border: none;
            outline: none;
            color: white;
            font-family: inherit;
            font-weight: 800;
            font-size: 6rem;
            text-align: center;
            width: 6ch;
            padding: 0;
            margin: 0;
            line-height: 1;
            cursor: text;
        }
        .bitrate-input::-webkit-outer-spin-button,
        .bitrate-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .bitrate-input {
            -moz-appearance: textfield;
        }
        #conversion-status-container {
            position: absolute;
            bottom: -80px; /* Position below the circle */
            width: 250px;
            text-align: center;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body class="dark:bg-slate-900 dark:text-gray-200">

    <!-- The Draggable Circle Buttons -->
    <div id="circle-1" class="draggable-circle bg-gray-400 hover:bg-gray-500 dark:bg-slate-600 dark:hover:bg-slate-500 shadow-lg">
        <span class="text-4xl font-semibold">FILE TO</span>
        <div class="h-28 flex items-center justify-center">
            <span class="text-8xl font-extrabold">MP4</span>
        </div>
    </div>
    <div id="circle-2" class="draggable-circle bg-gray-600 hover:bg-gray-700 dark:bg-slate-800 dark:hover:bg-slate-700 shadow-lg">
        <span class="text-4xl font-semibold">BITRATE</span>
        <div class="h-28 flex items-center justify-center">
            <input type="number" value="2" class="bitrate-input">
        </div>
        <!-- Conversion status will appear here -->
        <div id="conversion-status-container" class="opacity-0">
            <div id="progress-container" class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-3">
                <div id="progress-bar" class="bg-teal-500 h-3 rounded-full" style="width: 0%"></div>
            </div>
            <p id="status-text" class="h-6 text-sm text-slate-600 dark:text-slate-400 font-semibold mt-2"></p>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="file-input-hidden" hidden accept="video/*">

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileCircleEl = document.getElementById('circle-1');
            const bitrateCircleEl = document.getElementById('circle-2');
            const bitrateInput = document.querySelector('.bitrate-input');
            const hiddenFileInput = document.getElementById('file-input-hidden');
            const statusContainer = document.getElementById('conversion-status-container');
            const progressBar = document.getElementById('progress-bar');
            const statusText = document.getElementById('status-text');

            const CIRCLE_DIAMETER = 300;
            const CIRCLE_RADIUS = CIRCLE_DIAMETER / 2;

            const circles = [
                { el: fileCircleEl, x: 0, y: 0, vx: 0, vy: 0, radius: CIRCLE_RADIUS, scaleX: 1, scaleY: 1, squish: 0 },
                { el: bitrateCircleEl, x: 0, y: 0, vx: 0, vy: 0, radius: CIRCLE_RADIUS, scaleX: 1, scaleY: 1, squish: 0 }
            ];

            let activeElement = null;
            let followerElement = null;
            let mouse = { x: 0, y: 0, down: false };
            let wasDragging = false;
            let conversionInterval = null;

            // --- Physics Constants (Tuned for a floaty/soft feel) ---
            const DRAG_STRENGTH = 0.009;
            const FOLLOW_STRENGTH = 0.0001;
            const FRICTION = 0.97;
            const BOUNCE = 0.4;
            const SQUISH_RECOVERY = 0.2;
            const SQUISH_MAX = 0.15; // Reduced for less squish

            // --- Initial Positioning ---
            function initPositions() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const gap = 40;
                const totalWidth = (circles.length * CIRCLE_DIAMETER) + gap;
                const startX = centerX - (totalWidth / 2);

                circles.forEach((circle, index) => {
                    circle.x = startX + (index * (CIRCLE_DIAMETER + gap));
                    circle.y = centerY - CIRCLE_RADIUS;
                    circle.el.style.transform = `translate3d(${circle.x}px, ${circle.y}px, 0)`;
                });
            }

            // --- Interaction Handlers ---
            function interactionStart(e) {
                if (e.target === bitrateInput) {
                    e.target.focus();
                    return;
                }
                const targetCircleEl = e.target.closest('.draggable-circle');
                if (!targetCircleEl) return;
                
                activeElement = circles.find(c => c.el === targetCircleEl);
                followerElement = circles.find(c => c.el !== targetCircleEl);

                if (activeElement) {
                    updateMousePosition(e);
                    mouse.down = true;
                    wasDragging = false;
                    activeElement.el.classList.add('dragging');

                    // Add move and end listeners only when a drag starts
                    document.addEventListener('mousemove', interactionMove);
                    document.addEventListener('touchmove', interactionMove, { passive: false });
                    document.addEventListener('mouseup', interactionEnd);
                    document.addEventListener('touchend', interactionEnd);
                }
            }

            function interactionMove(e) {
                if (!mouse.down) return;
                if (!wasDragging) wasDragging = true;
                e.preventDefault(); // Prevent text selection/scrolling during drag
                updateMousePosition(e);
            }

            function interactionEnd() {
                if (!wasDragging && activeElement && activeElement.el === fileCircleEl) {
                     resetApp();
                     hiddenFileInput.click();
                }
                
                mouse.down = false;
                if (activeElement) {
                    activeElement.el.classList.remove('dragging');
                }
                activeElement = null;
                followerElement = null;

                // Crucially, remove listeners when the drag ends
                document.removeEventListener('mousemove', interactionMove);
                document.removeEventListener('touchmove', interactionMove);
                document.removeEventListener('mouseup', interactionEnd);
                document.removeEventListener('touchend', interactionEnd);
            }

            function updateMousePosition(e) {
                if (e.touches) {
                    mouse.x = e.touches[0].clientX;
                    mouse.y = e.touches[0].clientY;
                } else {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                }
            }

            // --- Physics and Animation Loop ---
            function update() {
                if (activeElement && followerElement) {
                    const dx = activeElement.x - followerElement.x;
                    const dy = activeElement.y - followerElement.y;
                    followerElement.vx += dx * FOLLOW_STRENGTH;
                    followerElement.vy += dy * FOLLOW_STRENGTH;
                }

                if (mouse.down && activeElement) {
                    const dx = mouse.x - (activeElement.x + activeElement.radius);
                    const dy = mouse.y - (activeElement.y + activeElement.radius);
                    activeElement.vx += dx * DRAG_STRENGTH;
                    activeElement.vy += dy * DRAG_STRENGTH;
                }
                
                const dist_x = circles[1].x - circles[0].x;
                const dist_y = circles[1].y - circles[0].y;
                const distance = Math.sqrt(dist_x * dist_x + dist_y * dist_y);

                if (distance < CIRCLE_DIAMETER) {
                    resolveCollision(circles[0], circles[1]);
                }

                circles.forEach(circle => {
                    circle.vx *= FRICTION;
                    circle.vy *= FRICTION;
                    circle.x += circle.vx;
                    circle.y += circle.vy;

                    // Squish effect logic
                    circle.squish *= (1 - SQUISH_RECOVERY); // Gradually recover from squish
                    const squishX = 1 - circle.squish;
                    const squishY = 1 + circle.squish;
                    
                    circle.el.style.transform = `translate3d(${circle.x}px, ${circle.y}px, 0) scale(${squishX}, ${squishY})`;

                    checkWallCollision(circle);
                });

                requestAnimationFrame(update);
            }
            
            function checkWallCollision(circle) {
                if (circle.x < 0) {
                    circle.x = 0;
                    circle.vx *= -BOUNCE;
                } else if (circle.x + CIRCLE_DIAMETER > window.innerWidth) {
                    circle.x = window.innerWidth - CIRCLE_DIAMETER;
                    circle.vx *= -BOUNCE;
                }
                if (circle.y < 0) {
                    circle.y = 0;
                    circle.vy *= -BOUNCE;
                } else if (circle.y + CIRCLE_DIAMETER > window.innerHeight) {
                    circle.y = window.innerHeight - CIRCLE_DIAMETER;
                    circle.vy *= -BOUNCE;
                }
            }
            
            function resolveCollision(c1, c2) {
                c1.squish = SQUISH_MAX;
                c2.squish = SQUISH_MAX;

                const dx = c2.x - c1.x;
                const dy = c2.y - c1.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                const overlap = (CIRCLE_DIAMETER - distance) / 2;
                const nx = dx / distance;
                const ny = dy / distance;

                c1.x -= overlap * nx;
                c1.y -= overlap * ny;
                c2.x += overlap * nx;
                c2.y += overlap * ny;

                const rvx = c2.vx - c1.vx;
                const rvy = c2.vy - c1.vy;
                const velAlongNormal = rvx * nx + rvy * ny;

                if (velAlongNormal > 0) return;

                const impulse = -(1 + BOUNCE) * velAlongNormal / 2;
                c1.vx -= impulse * nx;
                c1.vy -= impulse * ny;
                c2.vx += impulse * nx;
                c2.vy += impulse * ny;
            }

            // --- Conversion Logic ---
            const realConversion = async (file) => {
                if (conversionInterval) clearInterval(conversionInterval);

                const bitrate = bitrateInput.value;
                const formData = new FormData();
                formData.append('video', file);
                formData.append('bitrate', bitrate);

                console.log(`Uploading ${file.name} for conversion with bitrate ${bitrate}...`);

                statusContainer.classList.remove('opacity-0');
                statusText.textContent = "Uploading...";
                let progress = 0;
                progressBar.style.width = '0%';
                
                // Simulate upload progress
                conversionInterval = setInterval(() => {
                    progress += 10;
                    if (progress > 50) progress = 50; // Cap upload simulation at 50%
                    progressBar.style.width = `${progress}%`;
                    if (progress >= 50) clearInterval(conversionInterval);
                }, 100);

                try {
                    // Send the file to your local backend server
                    const response = await fetch('https://tlk-mp4-maker.onrender.com/convert', {
                        method: 'POST',
                        body: formData,
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Server error: ${errorText}`);
                    }
                    
                    statusText.textContent = "Converting...";
                    // Simulate conversion progress
                     conversionInterval = setInterval(() => {
                        progress += 5;
                        if (progress > 100) progress = 100;
                        progressBar.style.width = `${progress}%`;
                        if (progress >= 100) {
                           clearInterval(conversionInterval);
                           statusText.textContent = "Downloading...";
                        }
                    }, 200);


                    // Get the converted file back from the server
                    const blob = await response.blob();
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = downloadUrl;
                    
                    // Create a new filename for the download
                    const originalName = file.name.substring(0, file.name.lastIndexOf('.'));
                    a.download = `${originalName}_bitrate_${bitrate}.mp4`;
                    
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(downloadUrl);
                    document.body.removeChild(a);

                    statusText.textContent = "Done!";
                    setTimeout(() => statusContainer.classList.add('opacity-0'), 2000);

                } catch (error) {
                    console.error('Conversion failed:', error);
                    statusText.textContent = "Conversion Failed!";
                }
            };

            const resetApp = () => {
                if (conversionInterval) clearInterval(conversionInterval);
                hiddenFileInput.value = "";
                statusContainer.classList.add('opacity-0');
                statusText.textContent = "";
                progressBar.style.width = '0%';
            };

            // --- Event Listeners ---
            hiddenFileInput.addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    realConversion(event.target.files[0]);
                }
            });
            document.body.addEventListener('mousedown', interactionStart);
            document.body.addEventListener('touchstart', interactionStart, { passive: false });
            
            initPositions();
            update();
        });
    </script>
</body>
</html>
